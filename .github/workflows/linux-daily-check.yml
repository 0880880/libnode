name: Linux

on:
  push:
    tags:
      - "v*"
  workflow_dispatch:

jobs:
  update:
    runs-on: ubuntu-latest # Still use ubuntu-latest runner, but the container below will be specific
    strategy:
      fail-fast: false # Optional: Prevent cancelling other jobs if one fails
      matrix:
        arch: [amd64, arm64]
        include:
          # Map matrix arch names to manylinux arch names
          - arch: amd64
            manylinux_arch: x86_64
          - arch: arm64
            manylinux_arch: aarch64
            # is_arm flag is no longer strictly needed as we'll be native
    container:
      # Dynamically select the container image based on the matrix architecture
      image: quay.io/pypa/manylinux_2_28_${{ matrix.manylinux_arch }}
    steps:
      - uses: actions/checkout@v4

      - name: Setup ccache
        uses: actions/cache@v4
        with:
          path: .ccache
          save-always: true
          key: ccache-${{ github.workflow }}-${{ matrix.arch }}-${{ hashFiles('**/version.txt') }} # Added prefix for clarity
          restore-keys: |
            ccache-${{ github.workflow }}-${{ matrix.arch }}-

      - name: Install building tools (Native Arch)
        run: |
          # Running natively on x86_64 or aarch64 depending on the container
          echo "--- System Architecture ---"
          uname -m
          echo "--- Installing tools ---"
          dnf update -y
          # Install EPEL (should be present in manylinux, but good practice)
          dnf install -y epel-release || echo "EPEL already installed or failed, continuing..."
          # Install GCC Toolset 12 for a modern compiler (works on both x86_64 and aarch64)
          dnf install -y gcc-toolset-12-gcc gcc-toolset-12-gcc-c++ gcc-toolset-12-binutils
          # Install other required tools
          dnf install -y make git python3 python3-pip nasm ccache
          # Install Node.js
          curl -sL https://rpm.nodesource.com/setup_21.x | bash -
          dnf install -y nodejs
          echo "--- Tool installation complete ---"
          # No need for cross-compiler installation anymore

      - name: Run the script (Native Arch)
        # Use scl enable with the correct toolset name
        shell: scl enable gcc-toolset-12 -- bash {0}
        env:
          ARCH: ${{ matrix.arch }}
          # Use the native compilers provided by the SCL toolset
          CC: "gcc"
          CXX: "g++"
          CFLAGS: "-O2 -fPIC"
          # Allow Node.js build system to set C++ standard, keep OpenSSL fix
          CXXFLAGS: "-O2 -fPIC -Wno-error=deprecated-declarations"
          LDFLAGS: "-Wl,--as-needed"
          # CCACHE setup
          CCACHE_COMPRESS: "true"
          CCACHE_BASEDIR: "$GITHUB_WORKSPACE"
          CCACHE_DIR: "$GITHUB_WORKSPACE/.ccache"
        run: |
          echo "--- System Architecture ---"
          uname -m
          echo "--- Verifying Compiler Versions (within SCL) ---"
          which gcc
          ${CC} --version
          which g++
          ${CXX} --version
          echo "--- End Verification ---"

          # Ensure ccache directory exists
          mkdir -p "$CCACHE_DIR"

          # Prepend ccache to the PATH *within* the SCL environment
          # Use the standard ccache path (adjust if needed based on `rpm -ql ccache`)
          export PATH="/usr/lib64/ccache:$PATH"

          echo "PATH is: $PATH"
          echo "Building for ARCH: $ARCH"
          echo "Using CC: $(which ${CC})"
          echo "Using CXX: $(which ${CXX})"

          # Set cache size (optional, but good practice)
          ccache -M 5G
          ccache -s # Print stats before build

          # Run the build
          node index.js

          ccache -s # Print stats after build

      - name: Create archive
        run: |
          # Assuming the output path is consistent
          cd node/out/Release
          # Handle potential variations in .so naming if needed, but this should often work
          SO_FILE=$(ls libnode.so.* | head -n 1)
          if [ -z "$SO_FILE" ]; then
            echo "Error: Could not find libnode.so.* file!"
            exit 1
          fi
          ln -sf "$SO_FILE" libnode.so
          ls -l libnode.* node # Debugging output
          tar -cvJf "libnode-${{ matrix.arch }}-linux.tar.xz" libnode.so* node
          echo "Created archive libnode-${{ matrix.arch }}-linux.tar.xz"

      - name: Upload binaries to release
        uses: svenstaro/upload-release-action@v2
        with:
          overwrite: true
          tag: ${{ github.ref }}
          repo_token: ${{ secrets.GITHUB_TOKEN }}
          # Use a wildcard to be safer if the exact archive name changes slightly
          file: node/out/Release/libnode-${{ matrix.arch }}-linux.tar.xz
          file_glob: true # Recommended if using wildcards, but specific name should be fine too
